#!/usr/bin/env python3
import json, os, shutil, sys
from pathlib import Path


# The suffix that we use as a convention to identify exports which represent applications rather than binaries
APPLICATION_SUFFIX = '.desktop'


# Remove `~/.local/bin` from the PATH to ensure we can correctly identify the container filesystem location for binaries, without
# any risk of inadvertently selecting an alias that was previously generated by the `distrobox export` command
local_bin = str(Path('~/.local/bin').expanduser())
path_entries = os.environ.get('PATH').split(':')
path_entries = [e for e in path_entries if e != local_bin]
os.environ['PATH'] = ':'.join(path_entries)

# Resolve the list of directories in which we search for `.desktop` files. This is based loosely on the search logic used by the
# `distrobox export` command to resolve desktop files when an application is exported without specifying an absolute path:
# <https://github.com/89luca89/distrobox/blob/1.8.2.2/distrobox-export#L436-L451>
# 
# Note that we specifically deviate from the default Distrobox behaviour here and DO NOT include `~/.local/share/applications` or
# "$XDG_DATA_HOME/applications" in our list, since including those directories can result in clashes with existing desktop files.
# This is particularly relevant in the scenario where the container name is the same as the application name, since Distrobox will
# automatically create a desktop file for each container that opens a terminal inside the container. Including the directory where
# Distrobox generates desktop files may inadvertently export the desktop file that opens a terminal in the container, rather than
# the desktop file for the application inside the container that we are interested in.
desktop_search_paths = []
xdg_data_dirs = os.environ.get('XDG_DATA_DIRS', '')
if len(xdg_data_dirs) > 0:
	desktop_search_paths = [(Path(data_dir) / 'applications') for data_dir in xdg_data_dirs.split(':')]
else:
	desktop_search_paths = [
		Path('/usr/share/applications'),
		Path('/usr/local/share/applications'),
		Path('/var/lib/flatpak/exports/share/applications')
	]

# Read our list of exports from stdin
exports = sys.stdin.read().split()
processed = {
	'applications': {},
	'binaries': {}
}

# Sort the exports into applications and binaries, and resolve the absolute paths for any binaries
for export in exports:
	if export.endswith(APPLICATION_SUFFIX):
		
		# Attempt to resolve the absolute path to the specified `.desktop` file
		application = None
		candidates = [search_path / export for search_path in desktop_search_paths]
		exists = [candidate for candidate in candidates if candidate.exists()]
		if len(exists) > 0:
			application = exists[0]
		else:
			raise RuntimeError(f'could not find application "{ export }" in the search paths for .desktop files')
		
		# Add the resolved path to our list
		processed['applications'][export] = str(application)
		
	else:
		
		# Attempt to resolve the absolute path to the specified binary
		binary = shutil.which(export)
		if binary is None:
			raise RuntimeError(f'could not find binary "{ export }" in the PATH')
		
		# Add the resolved path to our list
		processed['binaries'][export] = binary

# Sort our processed exports
processed['applications'] = dict(sorted(processed['applications'].items()))
processed['binaries'] = dict(sorted(processed['binaries'].items()))

# Write the processed exports to disk for later use by the `apply-exports.py` and `generate-manifest.py` scripts
with open('/container-exports.json', 'w') as outfile:
	json.dump(processed, outfile, indent=True)
